<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pac-Man ‚Äî –ú–∏–Ω–∏-–∏–≥—Ä–∞</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; touch-action: none; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0d0d0d;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 8px;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 400px;
      margin-bottom: 6px;
      font-size: 15px;
      gap: 12px;
    }
    .hud-score { font-weight: bold; color: #ffd700; }
    .hud-hearts { font-size: 18px; letter-spacing: 2px; }
    .hud-level { color: #aaa; font-size: 13px; }
    #gameCanvas {
      display: block;
      background: #000;
      border-radius: 8px;
      max-width: 100%;
      max-height: 70vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .controls {
      display: grid;
      grid-template: " . up . " " left . right " " . down . ";
      gap: 4px;
      margin-top: 12px;
      max-width: 180px;
    }
    .controls button {
      width: 48px;
      height: 48px;
      border: none;
      border-radius: 8px;
      background: #334155;
      color: #f1f5f9;
      font-size: 18px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .controls button:active { background: #475569; color: #ffd700; }
    .controls .up { grid-area: up; }
    .controls .left { grid-area: left; }
    .controls .right { grid-area: right; }
    .controls .down { grid-area: down; }
    #startBtn {
      margin-top: 12px;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 12px;
      background: #ffd700;
      color: #000;
      font-weight: bold;
      cursor: pointer;
    }
    #startBtn:active { opacity: 0.9; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="hud">
    <span class="hud-score">‚≠ê <span id="scoreEl">0</span></span>
    <span class="hud-hearts" id="livesEl">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
    <span class="hud-level" id="levelEl">–ö–∞—Ä—Ç–∞ 1/6</span>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div class="controls">
    <button type="button" class="up" data-dir="up">‚Üë</button>
    <button type="button" class="left" data-dir="left">‚Üê</button>
    <button type="button" class="right" data-dir="right">‚Üí</button>
    <button type="button" class="down" data-dir="down">‚Üì</button>
  </div>
  <button type="button" id="startBtn">–ò–≥—Ä–∞—Ç—å</button>

  <script>
(function() {
  const tg = window.Telegram && window.Telegram.WebApp;
  if (tg) {
    tg.ready();
    tg.expand();
    if (tg.themeParams && tg.themeParams.bg_color) {
      document.body.style.background = tg.themeParams.bg_color;
    }
  }

  const CELL = 16;
  const COLS = 19;
  const ROWS = 21;
  const W = COLS * CELL;
  const H = ROWS * CELL;
  const WALL = 1, DOT = 2, POWER = 3, EMPTY = 0;

  const PAC_SPEED = 0.1;
  const POWER_SEC = 8;
  let ghostTick = 0;

  const MAZES = [
    [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
      [1,3,1,1,2,1,1,2,1,2,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,2,1,2,1,1,1,2,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,2,2,1],
      [1,1,1,1,2,1,1,0,1,0,1,1,2,1,1,2,1,1,1],
      [0,0,0,1,2,1,0,0,0,0,0,1,2,1,1,2,1,0,0],
      [1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,2,1,1,1],
      [1,2,2,2,2,2,0,1,0,1,0,2,2,2,2,2,2,2,1],
      [1,1,1,1,2,1,0,1,1,1,0,1,1,1,1,2,1,1,1],
      [0,0,0,1,2,1,0,0,0,0,0,1,2,1,1,2,1,0,0],
      [1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,2,1,1,1],
      [1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1],
      [1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1],
      [1,1,2,1,2,1,2,1,1,1,2,1,2,1,2,1,1,2,1],
      [1,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ],
    [
      [1,1,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1],
      [1,2,2,2,1,0,0,0,1,0,0,0,1,2,2,2,2,2,1],
      [1,2,3,2,1,0,0,0,0,0,0,0,1,2,1,1,1,2,1],
      [1,2,2,2,1,0,0,0,1,0,0,0,1,2,2,2,2,2,1],
      [1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1],
      [0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
      [1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,0,1,0,1,0,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,0,1,0,1,0,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1],
      [0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
      [1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,1],
      [1,2,2,2,1,0,0,0,1,0,0,0,1,2,2,2,2,3,1],
      [1,1,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1]
    ],
    [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1],
      [1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1],
      [1,2,1,2,1,1,1,1,0,1,1,1,1,1,1,2,1,2,1],
      [1,2,2,2,2,2,2,1,0,1,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,2,1,0,1,2,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,1,2,1,0,1,2,1,0,0,0,0,0,0,0],
      [1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,0,1,0,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,1,2,1,0,1,2,1,0,0,0,0,0,0,0],
      [1,1,1,1,1,1,2,1,0,1,2,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ],
    [
      [1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,1,0,1,0,1,2,2,2,2,2,2,2,1],
      [1,2,1,1,2,2,1,0,0,0,1,2,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,1,0,1,0,1,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
      [1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
      [1,1,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,1,0,1,0,1,2,2,2,2,2,2,2,1],
      [1,2,1,1,2,2,1,0,0,0,1,2,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,1,0,1,0,1,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ],
    [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ],
    [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,2,1],
      [1,2,3,2,1,2,1,2,1,2,1,2,1,2,1,1,1,2,1],
      [1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,2,1],
      [1,1,1,0,1,1,1,0,0,0,1,1,1,0,1,1,1,1,1],
      [1,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,1],
      [1,2,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0],
      [1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,1],
      [1,1,1,1,0,1,1,1,0,0,0,1,1,1,0,1,1,1,1],
      [1,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,1],
      [1,2,1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,2,1],
      [1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ]
  ];

  const SPAWN = { pac: { x: 9, y: 15 }, ghosts: [{x:9,y:9},{x:8,y:9},{x:10,y:9}] };

  let currentLevel = 0;
  let maze = MAZES[0].map(r => r.slice());
  let dotsLeft = 0;
  function countDots() {
    let n = 0;
    for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
      if (maze[r][c] === DOT || maze[r][c] === POWER) n++;
    }
    return n;
  }

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('scoreEl');
  const livesEl = document.getElementById('livesEl');
  const levelEl = document.getElementById('levelEl');
  const startBtn = document.getElementById('startBtn');

  const dirs = [{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];
  let pac = { px: 9, py: 15, dir: 0, nextDir: 0, frame: 0 };
  let ghosts = [
    { px: 9, py: 9, dir: 0, color: '#f00', delay: 0 },
    { px: 8, py: 9, dir: 2, color: '#ff88ff', delay: 45 },
    { px: 10, py: 9, dir: 1, color: '#00ffff', delay: 90 }
  ];
  let score = 0, lives = 3;
  let powerUntil = 0;
  let running = false;
  let gameOver = false;
  let won = false;

  let scale = 1;
  function resize() {
    const maxW = Math.min(window.innerWidth - 16, W);
    const maxH = Math.min(window.innerHeight * 0.7 - 16, H);
    scale = Math.min(maxW / W, maxH / H, 2) || 1;
    canvas.width = W;
    canvas.height = H;
    canvas.style.width = (W * scale) + 'px';
    canvas.style.height = (H * scale) + 'px';
  }
  resize();
  window.addEventListener('resize', resize);

  function getTile(r, c) {
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return WALL;
    return maze[r][c];
  }
  function canGo(r, c) {
    return getTile(r, c) !== WALL;
  }

  function setLevel(level) {
    currentLevel = level;
    maze = MAZES[level].map(r => r.slice());
    dotsLeft = countDots();
    const sp = SPAWN.pac;
    const gs = SPAWN.ghosts;
    pac = { px: sp.x, py: sp.y, dir: 0, nextDir: 0, frame: 0 };
    ghosts = [
      { px: gs[0].x, py: gs[0].y, dir: 0, color: '#f00', delay: 0 },
      { px: gs[1].x, py: gs[1].y, dir: 2, color: '#ff88ff', delay: 45 },
      { px: gs[2].x, py: gs[2].y, dir: 1, color: '#00ffff', delay: 90 }
    ];
    powerUntil = 0;
    levelEl.textContent = '–ö–∞—Ä—Ç–∞ ' + (level + 1) + '/6';
  }

  function updateHearts() {
    livesEl.textContent = '‚ù§Ô∏è'.repeat(lives) || 'üíÄ';
  }

  function startGame() {
    setLevel(0);
    score = 0;
    lives = 3;
    gameOver = false;
    won = false;
    scoreEl.textContent = '0';
    updateHearts();
    levelEl.textContent = '–ö–∞—Ä—Ç–∞ 1/6';
    startBtn.classList.add('hidden');
    running = true;
  }

  function nextLevel() {
    if (currentLevel >= MAZES.length - 1) {
      won = true;
      gameOver = true;
      running = false;
      startBtn.textContent = '–ü–æ–±–µ–¥–∞! –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞';
      startBtn.classList.remove('hidden');
      return;
    }
    setLevel(currentLevel + 1);
    setTimeout(() => { running = true; }, 800);
  }

  function loseLife() {
    lives--;
    updateHearts();
    if (lives <= 0) {
      gameOver = true;
      running = false;
      startBtn.textContent = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞. –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞';
      startBtn.classList.remove('hidden');
      return;
    }
    setLevel(currentLevel);
    setTimeout(() => { running = true; }, 1000);
  }

  function drawMaze() {
    ctx.fillStyle = '#0a0a12';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#1a1a3a';
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (maze[r][c] === WALL) {
          ctx.fillRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
        } else if (maze[r][c] === DOT) {
          ctx.fillStyle = '#ffd700';
          ctx.beginPath();
          ctx.arc(c * CELL + CELL/2, r * CELL + CELL/2, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#1a1a3a';
        } else if (maze[r][c] === POWER) {
          ctx.fillStyle = '#ffaa00';
          ctx.beginPath();
          ctx.arc(c * CELL + CELL/2, r * CELL + CELL/2, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#1a1a3a';
        }
      }
    }
  }

  function drawPacman() {
    const x = pac.px * CELL + CELL/2;
    const y = pac.py * CELL + CELL/2;
    const open = 0.2 + Math.sin(pac.frame * 0.4) * 0.25;
    const start = (pac.dir * Math.PI / 2) + open * Math.PI;
    const end = (pac.dir * Math.PI / 2) - open * Math.PI;
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.arc(x, y, CELL/2 - 1, start, end + Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    pac.frame++;
  }

  function drawGhost(g, edible) {
    const x = g.px * CELL + CELL/2;
    const y = g.py * CELL + CELL/2;
    ctx.fillStyle = edible ? '#2222ff' : g.color;
    ctx.beginPath();
    ctx.arc(x, y - 2, CELL/2 - 2, Math.PI, 0);
    ctx.lineTo(x + CELL/2 - 2, y + 4);
    ctx.lineTo(x, y + 2);
    ctx.lineTo(x - CELL/2 + 2, y + 4);
    ctx.closePath();
    ctx.fill();
    if (!edible) {
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - 4, y - 4, 3, 0, Math.PI * 2);
      ctx.arc(x + 4, y - 4, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#00f';
      ctx.beginPath();
      ctx.arc(x - 4, y - 4, 1.5, 0, Math.PI * 2);
      ctx.arc(x + 4, y - 4, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function movePacman(dt) {
    const step = PAC_SPEED * (dt / 16);
    const d = dirs[pac.nextDir];
    const nextCellC = Math.floor(pac.px + d.x + 0.5);
    const nextCellR = Math.floor(pac.py + d.y + 0.5);
    if (canGo(nextCellR, nextCellC)) pac.dir = pac.nextDir;
    const d2 = dirs[pac.dir];
    const nextC = Math.floor(pac.px + d2.x + 0.5);
    const nextR = Math.floor(pac.py + d2.y + 0.5);
    if (!canGo(nextR, nextC)) return;
    pac.px = Math.max(0, Math.min(COLS - 0.01, pac.px + d2.x * step));
    pac.py = Math.max(0, Math.min(ROWS - 0.01, pac.py + d2.y * step));
    const cr = Math.round(pac.py);
    const cc = Math.round(pac.px);
    if (cr >= 0 && cr < ROWS && cc >= 0 && cc < COLS) {
      if (maze[cr][cc] === DOT) {
        maze[cr][cc] = EMPTY;
        score += 10;
        dotsLeft--;
      } else if (maze[cr][cc] === POWER) {
        maze[cr][cc] = EMPTY;
        score += 50;
        powerUntil = Date.now() + POWER_SEC * 1000;
        dotsLeft--;
      }
    }
  }

  function moveGhostStep(g) {
    if (g.delay > 0) { g.delay--; return; }
    const edible = powerUntil > Date.now();
    const gx = Math.round(g.px), gy = Math.round(g.py);
    const choices = [];
    for (let i = 0; i < 4; i++) {
      const d = dirs[i];
      const nr = gy + d.y, nc = gx + d.x;
      if (canGo(nr, nc)) {
        const dist = (nr - pac.py)**2 + (nc - pac.px)**2;
        choices.push({ i, nr, nc, dist });
      }
    }
    if (choices.length === 0) return;
    choices.sort((a, b) => edible ? (b.dist - a.dist) : (a.dist - b.dist));
    g.dir = choices[0].i;
    g.px = choices[0].nc;
    g.py = choices[0].nr;
  }

  function checkCollision() {
    const pr = Math.round(pac.py), pc = Math.round(pac.px);
    if (powerUntil > Date.now()) {
      for (const g of ghosts) {
        const gr = Math.round(g.py), gc = Math.round(g.px);
        if (pr === gr && pc === gc) {
          g.px = SPAWN.ghosts[0].x; g.py = SPAWN.ghosts[0].y;
          g.delay = 90;
          score += 200;
        }
      }
    } else {
      for (const g of ghosts) {
        if (g.delay <= 0 && pr === Math.round(g.py) && pc === Math.round(g.px)) {
          loseLife();
          return;
        }
      }
    }
  }

  let lastTime = performance.now();
  function loop(now) {
    const dt = Math.min(now - lastTime, 50);
    lastTime = now;

    if (!running) {
      drawMaze();
      drawPacman();
      ghosts.forEach(g => drawGhost(g, powerUntil > Date.now()));
      if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 22px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(won ? '–ü–æ–±–µ–¥–∞!' : '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞', W/2, H/2 - 12);
        ctx.fillText('–û—á–∫–∏: ' + score, W/2, H/2 + 14);
        if (won && currentLevel < MAZES.length - 1) ctx.fillText('–ö–∞—Ä—Ç–∞ ' + (currentLevel + 1) + ' –ø—Ä–æ–π–¥–µ–Ω–∞!', W/2, H/2 + 38);
      }
      requestAnimationFrame(loop);
      return;
    }

    movePacman(dt);
    ghostTick += dt;
    if (ghostTick >= 120) {
      ghostTick = 0;
      ghosts.forEach(moveGhostStep);
      checkCollision();
    }

    if (dotsLeft <= 0) {
      running = false;
      nextLevel();
    }

    drawMaze();
    drawPacman();
    ghosts.forEach(g => drawGhost(g, powerUntil > Date.now()));

    scoreEl.textContent = String(score);
    requestAnimationFrame(loop);
  }

  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { pac.nextDir = 0; e.preventDefault(); }
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { pac.nextDir = 1; e.preventDefault(); }
    if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { pac.nextDir = 2; e.preventDefault(); }
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { pac.nextDir = 3; e.preventDefault(); }
  });

  document.querySelectorAll('.controls button').forEach(btn => {
    btn.addEventListener('click', () => {
      const dir = btn.getAttribute('data-dir');
      if (dir === 'up') pac.nextDir = 0;
      if (dir === 'right') pac.nextDir = 1;
      if (dir === 'down') pac.nextDir = 2;
      if (dir === 'left') pac.nextDir = 3;
    });
  });

  startBtn.addEventListener('click', startGame);
  requestAnimationFrame(loop);
})();
  </script>
</body>
</html>
